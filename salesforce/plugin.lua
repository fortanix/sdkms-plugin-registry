-- Name: Cache-only BYOK for Salesforce Cloud
-- Version: 1.0
-- Description: ## Short Description
-- Fortanix Self-Defending KMS can be used as HSM backed Software-as-a-service(SAAS) for Fortanix - Salesforce Cache only BYOK solution. This plugin can be used to securely generate encryption keys and configure in Salesforce’s Shield Platform.
-- ### ## Introduction
-- Salesforce's Shield Platform Encryption is introducing a new pilot feature called Cache-Only Keys. This capability enhances the existing Bring Your Own Key (BYOK) capability by allowing customers to host their key material in a wrapped format which Salesforce will fetch as required. While this will be cached in an encrypted form, Salesforce will not retain or persist the key material in any system of record or backups.
--
-- ## Use cases
--
-- 1. Generate encryption keys 
-- 2. use Fortanix Self-Defending KMS key in Salesforce as Cache-only Key at runtime
--
-- ## Fortanix Self-Defending KMS Setup
--
-- 1. Log in to Fortanix Self-Defending KMS (https://sdkms.fortanix.com)
-- 2. Create an account in Fortanix Self-Defending KMS
-- 3. Create a group in Fortanix Self-Defending KMS
-- 4. Create an app in Fortanix Self-Defending KMS. Copy the value of App username and password. This would be required while setting up Named Credential in Salesforce.  
-- 5. Create a plugin in Fortanix Self-Defending KMS 
--
-- ## Configure Salesforce import Certificate in Fortanix Self-Defending KMS
--
-- Generate and Download a Self Signed Certificate in Salesforce and import it in fortanix Self-Defending KMS 
--
-- 1. Log in to Salesforce. Go to "Setup" 
-- 2. Create a (Self Signed) certificate under Security >> Certificate and Key Management with key size 4096.
-- 3. Disable the check box "Exportable Private Key"
-- 4. Select the check box to "Use Platform Encryption"
-- 5. Once the certificate is created, please download it
--
-- Import the Certificate to Fortanix Self-Defending KMS.
--
-- 1. Log in to Fortanix Self-Defending KMS
-- 2. Select an account and Click the left navigation bar to navigate to the "Security Objects" tab
-- 3. Click the IMPORT button
-- 4. Choose value format as “BASE 64”.
-- 5. Choose Security Object type as “Certificate”.
-- 6. Click the Upload a file button to upload the converted certificate at Step 5.
-- 7. Click the IMPORT button to import the certificate into Fortanix Self-Defending KMS as a security object.
--
-- ## Salesforce Setup
--
-- Define Named Credential in Salesforce.
--
-- 1. Log in to Salesforce. Go to "Setup"
-- 2. Click the “Named Credentials” item under the Security menu in the left navigation bar
-- 3. Click the button New Named Credential. It will open a screen to create a Named Credential
-- 4. Enter the details for named credential
-- 4.1 Enter Label & Name of your choice
-- 4.2 Enter the plugin URL as in example (UUID: UUID of the plugin created in the section Fortanix Self-Defending KMS Setup Step 3 ). Example: https://www.sdkms.fortanix.com/sys/v1/plugins/invoke/<plugin-uuid>
-- 4.3 Select the Identity Type as “Named Principal” and Authentication Protocol as “Password Authentication”
-- 4.4 Enter the username and password of Fortanix Self-Defending KMS app and then click Save
--
-- ## Steps to generate encryption keys and import to Salesforce
--
-- Generate JWE Token (BYOK Cache only KEY) using the plugin.
--
-- 1. Go to plugin created in Step 5 of section Fortanix Self-Defending KMS Setup.
-- 2. Click ADD TEST INPUT on the right-hand side.
-- 3. Enter the following payload in the text box.
--
-- ```
-- {
-- "cert": <uuid of certificate imported in SDKMS>,
-- "name": "<unique name of key eg: salesforce_ency_key_v1>"
-- }
-- ```
--
--4. RUN TEST
--
-- The plugin generates security objects (AES encryption key and meta information) in Fortanix Self-Defending KMS and returns their UUID.
--
-- 1. dek: is UUID of AES encryption key generated by the plugin and stored securely in Fortanix Self-Defending KMS. Salesforce will use it as a data encryption key.
-- 2. opq_key_identifier: Fortanix Self-Defending KMS plugin also generates a security object of type “OPAQUE”. It contains meta-information to generate a response (JWE Token) required by Salesforce. Meta-information has the following information:
--
-- Copy the value of “opq_key_identifier” field in the response body. This would be required while setting up BYOK in Salesforce.
--
-- When Salesforce platform calls Fortanix Self-Defending KMS plugin to fetch encryption keys. The plugin reads meta information from opaque object and processes "dek" key material and certificate used (while generating meta info and AES initially) to generate JWE token. The same is returned to Salesforce in the desired JSON format.
--
-- Refer salesforce documentation for more info on JWE token.
--
-- "dek” value is AES encryption key which is generated by the plugin and the key is stored in Fortanix Self-Defending KMS. The key material would be securely transferred to Salesforce as part of JWE token.
--
-- Go to the Security Objects screen to see the newly created object.
--
-- ## Configure Salesforce to use Fortanix Self-Defending KMS to fetch Cache-only Key at runtime.
--
-- 1. Go to Setup >> Security >> Platform Encryption >> Key Management
-- 2. Click the Bring Your Own Key button
-- 3. Select the desired certificate to be used (it should be same as the one used while executing plugin to generate an encryption key and meta information)
-- 4. Select Use a Cache-Only Key radio button.
-- 5. Select Named Credential created with Fortanix Self-Defending KMS endpoint.
-- 6. Enter BYOK ID (opq_key_identifier) generated by the Fortanix Self-Defending KMS plugin in Step 1.
-- 7. Click Save.
-- 8. Once the configuration is saved, Salesforce will call Fortanix Self-Defending KMS to fetch JWE token and decrypt it with the private key of the certificate.
-- 9. You can see the newly imported key on the “Key Management” screen
--
-- Verify the Key Import in the Fortanix Self-Defending KMS Event logs.
--
-- 1. Logs are generated in Fortanix Self-Defending KMS while fetching encryption keys during setup (after step 2i).
-- 2. Go to Event Logs in Fortanix Self-Defending KMS to verify (refer below screenshot).
-- 3. Logs are also generated later when Salesforce calls Fortanix Self-Defending KMS to fetch the encryption keys at runtime.
-- 
-- ## Reference
--
-- - Fortanix support (https://support.fortanix.com/hc/en-us/articles/360040488931-Exporting-Fortanix-Self-Defending-KMS-keys-to-Cloud-Providers-for-BYOK-Salesforce)
-- ### Release Notes                                                            
-- - Initial release

function Blob:base64_urlsafe()
  return (self:base64():gsub('+', '-'):gsub('/', '_'):gsub('=', ''))
end
function getNextKeyVersionLabelForVersion(name, version)
  availableName = name .. '_V' .. version
  key = Sobject { name = availableName }
  if not key then
    return availableName
  else
    return getNextKeyVersionLabelForVersion(name, version+1);
  end
end
function getNextKeyVersionLabel(name)
  return getNextKeyVersionLabelForVersion(name, 1)
end
function createKey(keyname, isTransient)
  return Sobject.create {
    obj_type = 'AES',
    key_size = 256,
    key_ops = {'ENCRYPT', 'DECRYPT', 'WRAPKEY', 'UNWRAPKEY', 'DERIVEKEY', 'EXPORT',
    'APPMANAGEABLE'},
    name = keyname,
    transient = isTransient
  }
end
function split (inputstr, sep) 
 if sep == nil then
   sep = "%s"
 end
 local t={}
 for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
   table.insert(t, str)
 end
 return t
end
function findOrCreateKey(kid, name)
  if not kid then
    cek = createKey(name, false)
  else
    cek = Sobject { kid = kid }
  end
  return cek;
end
function saveToOpaqueObject(name, value, desc)
  return Sobject.import {
    name = name,
    obj_type = 'OPAQUE',
    value = value,
    description = desc,
    transient = false
  };
end
function validateInput(input)
  if not Sobject { kid = input.cert } then
    return 'Unable to generate Key data, Cert not found'
  end
  --check if dek uuid is passed, else perform already exist validation
  if not input.dek then
    if not input.name then
      return 'Pass uuid of existing key or name for new dek'
    end
    if Sobject { name = input.name } then
      return 'Key ['.. input.name .. '] already generated for input name [' .. input.name
    .. ']'
    end
    if Sobject { name = input.name .. '_meta_info'} then
      return 'Meta info ['.. input.name .. '_meta_info' .. '] already generated for input name [' .. input.name .. ']'
    end
  else
    --check if input.dek is valid and meta info not already generated for same
    dek = Sobject { kid = input.dek }
    if not dek then
      return 'Invalid dek [' .. input.dek .. ']'
    else
      if Sobject { name = dek.name .. '_meta_info' } then
        return 'Meta info ['.. dek.name .. '_meta_info' .. '] already generated for input dek uuid [' .. input.dek .. ']'
      end
    end
  end
  return nil
end
function generateKeyAndMetaData(input)
  errormsg = validateInput(input)
  if errormsg then
    return { error = errormsg }
  end
  -- use dek passed or generate new one
  dek = findOrCreateKey(input.dek, input.name)
  key_info = '{ "dek":"' .. dek.kid
                .. '", "cert": "' .. input.cert .. '"}';
  opq_obj = saveToOpaqueObject(
    dek.name .. '_meta_info',
    Blob.from_bytes(key_info),
    'DEK = ' .. dek.kid .. ', cert = ' .. input.cert
  )
  return { opq_key_identifier = opq_obj.kid, dek = dek.kid};
end
function generateJWEForKey(input, opq_key_identifier, query)
  -- Generate JWE token and return using meta info store in OPQ object --
  -- Search for opaque object having BYOK key meta info
  if opq_key_identifier == nil then
    return 'Key identificer [opq_key_identifier] missing'
  else
    opq_meta_info = Sobject { kid = opq_key_identifier }
  end
  if not opq_meta_info then
    return 'Invalid key identificer passed ['.. opq_key_identifier ..']'
  end
  meta_info = json.decode(opq_meta_info.value:bytes())
  dek = Sobject { kid = meta_info.dek }
  if not dek then
    return 'Invalid dek reference stored in metadata'
  end
  local salesforce_cert = Sobject { kid = meta_info.cert }
  if not salesforce_cert then
    return nil, 'Invalid cert stored in metadata'
  end
  --get next available name to avoid name conflict
  local keyname = getNextKeyVersionLabel(this_plugin().name);
  cek = createKey(keyname .. '_cek', true)
  header = { alg = "RSA-OAEP", enc = "A256GCM", kid = opq_key_identifier}
  -- Add jti to header for replay detection if requestId is passed in the request
  if query ~= nil and string.match(query, "requestId") then
    local requestId = split(query, "=")[2]
	  header.jti = requestId
  end
  header = Blob.from_bytes(json.encode(header)):base64_urlsafe() 
  local wcek = assert(salesforce_cert:wrap {
    alg = 'RSA',
    subject = cek,
    mode = 'OAEP_MGF1_SHA1'
  })
  local wdek = assert(cek:wrap {
    ad = Blob.from_bytes(header), --authentication data
    tag_len = 128,
    mode = 'GCM',
    subject = dek,
    alg = 'AES'
  })
  local jweval = header .. '.' ..
  wcek.wrapped_key:base64_urlsafe() .. '.' ..
  wdek.iv:base64_urlsafe() .. '.' ..
  wdek.wrapped_key:base64_urlsafe() .. '.' ..
  wdek.tag:base64_urlsafe()
  return {kid= opq_key_identifier, jwe = jweval};
end
function run(input, url, method)
  -- Start Plugin called to generate a new BYOK Key
  if method == "POST" then
    -- Generate DEK and store in opq_obj along with other meta info for future API calls
    return generateKeyAndMetaData(input)
  else
    -- Generate JWE token and return using meta info store in OPQ object --
    return generateJWEForKey(input, url.path[6], url.query)
  end
end    
